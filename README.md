# University

## First Program ##

@brief  Search for biggest Subarray value of given Arrays.,
        To get Subarray value we need to use equasion:,
        sum(i,j) = 3 * P + 2 * N,
        i - index of first element in Subarray,
        j - index of last element in Subarray,
        P - positive element,
        N - Negative element,
        
@input  File with number of Arrays,
                  size of array,
                  Array*,
*- absolute value of elements in Array cant be bigger than 2000,

@output File with copy of an original Arrays,
                  i,j indexes of biggest Subarray,
                  value of biggest Subarray,

## Second Program ##

@brief  Searches for number of occurances of selected elements in given collection with O(log (n)) complexity,

@input  File  with size of collection,
                   collection,
                   number of searches*,
                   elements to search,
*- cant be bigger than size of collection and smaller than one,

@output File with searched element,
                  number of occurances,

## Third Program ##

#### Subprogram .1 ####

@brief  generates every possible permutation of given collection,

@input  File with collection,

@output File with permutations,

  #### Subprogram .2 ####

@brief  generates every possible permutation of given collection in anti lexicographic order,

@input  File with collection,

@output File with permutations,

  #### Subprogram .3 ####
  
@breif  generates every possible variation with multicombinations of given elements,

@input  Number of elements,

@output File with variations,

## Fourth Program ##

@brief  Generates random numbers using methods:
        > 
        >
        >
        >
        
        
## Fifth Program ##

@brief  Implement QuickSort algorithm in O(n*log2(n)) complexity that use pesimisticly O(1) additional memmory, w/o recurention,

@input File with number of sets,
                 size of set (from 1 to 15000),
                 set of elements (value from 0 to 2^48),

@output File with sorted elements in non-decreasing order
                  elements separated with ' ', one lane for one set,
                  

## Sixth Program ##

  #### Subprogram .1 ####
  
  @brief Transform list of incidents to a matrix of incidents and list all neigbours of tips,
  
  @input File with number of edges,
                   set of tips: Out-tip In-tip of Edge,
  
  @output File with matrix of incidents,
                    list of neighbour tips of every tip in graph,
  
  #### Subprogram .2 ####

  @brief
  
  @input File with

  @output File with

## Seventh Program ##

  #### Subprogram .1 ####
  
  @brief
  
  @input File with
  
  @output File with
  
  #### Subprogram .2 ####

  @brief
  
  @input File with

  @output File with

## Eighth Program ##

  @brief
  
  @input File with

  @output File with

## Ninth Program ##

  @brief
  
  @input File with

  @output File with
  
## Tenth Program ##

  @brief
  
  @input File with
  
  @output File with
